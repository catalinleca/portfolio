---
title: "HedgeHunt"
description: "Architecture and technical decisions behind a full-stack treasure hunt platform."
date: "2024-01-01"
tags: ["full-stack", "typescript", "monorepo", "react", "node"]
---

# HedgeHunt

A platform for creating and playing location-based treasure hunts.

<ExecutiveSummary
  problem="Content platform where creators build interactive treasure hunts and players solve them concurrently. Four challenge types with AI-powered validation. Editing and playing happen at the same time."
  constraints="Four independently deployed apps sharing one type system. Immutable content versions. AI failures can't block players."
  architecture="TypeScript monorepo with OpenAPI-generated types. MongoDB with optimistic concurrency. Server-side player format boundary for answer security."
  results="Atomic releases with instant rollback. Version-locked play sessions. Zero type drift across apps. Live at hedgehunt.app."
/>

---

## Overview

HedgeHunt lets creators build multi-step treasure hunts in a visual editor and players solve them on mobile using GPS, photos, and audio. The platform supports four challenge types: Clue (text-based riddles), Quiz (multiple choice or free-text input), Mission (GPS location verification and media capture), and Task (AI-validated audio and image submissions).

The Editor and Player are separate apps. Creators get real-time preview through an iframe that runs the actual Player app with stripped-down hunt data. The server controls game progression through HATEOAS links. Players never decide what comes next.

---

## Architecture

TypeScript monorepo with four apps and three shared packages.

`@hunthub/shared` holds API types and Zod schemas generated from a single OpenAPI spec. Every app imports from here. If the spec changes and a consumer doesn't update, CI fails at build time.

`@hunthub/compass` wraps MUI's `createTheme` into a shared package with custom design tokens, typography scales, and component overrides. Any app that imports it gets a consistent visual language without duplicating theme configuration.

`@hunthub/player-sdk` handles the typed postMessage protocol between Editor and Player. The Editor sends hunt data through a `PlayerExporter` that strips answer keys and AI instructions before the iframe receives them.

<Mermaid chart={`graph TD
  A[HuntHub Monorepo] --> B[Editor App]
  A --> C[Player App]
  A --> D[Backend API]
  A --> E[Landing Page]
  A --> F["@hunthub/shared"]
  A --> G["@hunthub/compass"]
  A --> H["@hunthub/player-sdk"]
  B --> F
  B --> G
  B --> H
  C --> F
  C --> G
  C --> H
  D --> F
  style A fill:#1a1a1e,stroke:#cc7832,stroke-width:2px,color:#eae8e4
  style B fill:#1a1a1e,stroke:#6897bb,stroke-width:2px,color:#eae8e4
  style C fill:#1a1a1e,stroke:#6897bb,stroke-width:2px,color:#eae8e4
  style D fill:#1a1a1e,stroke:#6a8759,stroke-width:2px,color:#eae8e4
  style E fill:#1a1a1e,stroke:#9b978f,stroke-width:2px,color:#eae8e4
  style F fill:#151518,stroke:#9876aa,stroke-width:2px,color:#eae8e4
  style G fill:#151518,stroke:#9876aa,stroke-width:2px,color:#eae8e4
  style H fill:#151518,stroke:#9876aa,stroke-width:2px,color:#eae8e4`}
  caption="HuntHub monorepo — 4 apps + 3 shared packages"
/>

The API runs on Fly.io. Editor and Player deploy to Vercel. The landing page ships to Cloudflare Pages. Static assets go through S3 with CloudFront as the CDN.

Hunts go through three states: Draft, Published, and Live. Publishing freezes the current content into an immutable snapshot. Releasing points live traffic to that snapshot. Rolling back switches the pointer to a previous version. No data migration, no downtime.

<Mermaid chart={`graph LR
  A[Draft] -->|Publish| B[Published]
  B -->|Set as Live| C[Live]
  B -->|Continue Editing| A
  C -->|New Draft| A`}
  caption="Hunt version lifecycle — Draft → Published → Live"
/>

---

## Decisions

<DecisionCard id="hunt-versioning" title="Hunt Versioning Model" defaultOpen>
<CardField label="Context">

Creators edit hunts while players are actively solving them. If a creator modifies step 3 while a player is on step 1, the player could eventually reach content that changed mid-session. We needed complete isolation between editing and playing.

</CardField>
<CardField label="Options">

- **Single document model.** One `Hunt` document with all steps embedded. Simple to query. But publishing means either deep-cloning the entire document (expensive, hard to track versions) or adding version flags to every field (complexity explosion). Editing and playing would share the same data.
- **Event sourcing.** Store every edit as an event, reconstruct state on read. Powerful but overkill at this scale. Makes every read path more expensive for a problem that doesn't need temporal queries.
- **Separate version documents.** `Hunt` holds metadata and a pointer to the live version. `HuntVersion` holds the frozen content snapshot. Steps are linked per version.

</CardField>
<CardField label="Decision">

We went with the three-model approach. `Hunt` is the master record with a `liveVersion` field pointing to whichever `HuntVersion` is currently live. Publishing clones the draft steps into a new `HuntVersion`. Releasing swaps the pointer. Rolling back swaps it to a different version.

The release itself is a single `findOneAndUpdate`:

```typescript
const result = await Hunt.findOneAndUpdate(
  { huntId, liveVersion: currentLiveVersion },
  { liveVersion: version, releasedAt: new Date(), releasedBy: userId },
  { new: true, session }
);
if (!result) {
  throw new ConflictError('Hunt was modified. Retry.');
}
```

The filter `liveVersion: currentLiveVersion` acts as optimistic locking. If someone else released between when we read and when we write, the filter matches nothing and we throw a conflict. No distributed locks, no queues.

Automatic version pruning protects against unbounded growth. Old published versions are cleaned up, but the currently live version is always protected from deletion.

</CardField>
<CardField label="Tradeoff">

More complex schema. Every read that needs step data requires two lookups (version, then steps). Publishing is heavier because we clone step documents. But version isolation is absolute. Creators can edit freely while players see consistent, frozen content. Rollback is a pointer swap.

</CardField>
</DecisionCard>

<DecisionCard id="why-mongodb" title="Why MongoDB">
<CardField label="Context">

Each challenge type has a completely different data shape. A Quiz has options, correct answers, and validation modes. A Mission has GPS coordinates, radius, and media requirements. A Task has AI prompts and audio settings. We needed storage that handles this polymorphism without fighting the schema.

</CardField>
<CardField label="Options">

- **PostgreSQL with table-per-type inheritance.** A base `steps` table joined to `quiz_steps`, `mission_steps`, etc. Strong typing via Prisma. But adding a new challenge type means a new migration, a new table, and updating every query that touches steps.
- **PostgreSQL with JSONB.** One `steps` table with a `challenge JSONB` column. Flexible storage, but Prisma doesn't validate JSONB contents. You lose type safety at the database layer.
- **MongoDB with embedded documents.** Steps are documents. The challenge field holds sub-objects for each type. Only one is populated. Adding a new challenge type means adding a field. No migrations.

</CardField>
<CardField label="Decision">

MongoDB. Challenges are naturally document-shaped with variable structures that map cleanly to embedded objects. The document model also fits the versioning system well. Publishing clones step documents, which is a straightforward `insertMany` rather than a multi-table transaction.

For numeric IDs (MongoDB defaults to ObjectIds), we built a `Counter` collection. Each model has a counter document. `findOneAndUpdate` with `$inc` gives sequential, race-condition-safe, human-readable IDs for URLs and display.

We gave up JOINs. Every "join" is an explicit batch query using `$in` on arrays of IDs to avoid N+1 patterns. We gave up cross-collection ACID, but `withTransaction` covers the critical paths: publish, release, and delete.

The weaker TypeScript integration compared to Prisma is mitigated by using OpenAPI-generated types as the source of truth. Mongoose schemas are secondary, not authoritative.

</CardField>
<CardField label="Tradeoff">

No compile-time query validation like Prisma provides. Some denormalization is needed since you can't JOIN. But the polymorphic challenge structure maps naturally to documents, and the OpenAPI-first approach means type safety comes from the spec, not the ORM.

</CardField>
</DecisionCard>

<DecisionCard id="player-exporter" title="Player Format (PlayerExporter)">
<CardField label="Context">

The full `Step` document contains everything: correct answers, AI validation prompts, scoring criteria, admin notes. Players must never see any of this. Filtering on the client is not an option because the data has already left the server. One missed field or a browser devtools inspection would leak answers.

</CardField>
<CardField label="Options">

- **Client-side filtering.** Send the full document, strip fields in the Player app. Fast to build. Fundamentally insecure. The data is already on the wire.
- **GraphQL field-level auth.** Let the client request only safe fields. Still risky if a field permission is misconfigured. A new sensitive field defaults to exposed unless someone remembers to restrict it.
- **Server-side transformation.** A dedicated function that takes a full `Step` and returns a `StepPF` (Player Format). The boundary is structural. The server never sends what it shouldn't.

</CardField>
<CardField label="Decision">

`PlayerExporter` runs server-side. It takes a full `Step` and produces a `StepPF` containing only what the player needs to see and interact with. Answer keys, AI prompts, validation criteria, and admin metadata are all stripped. Quiz options are randomized at this layer so the order is consistent within a session but unpredictable across sessions.

The same exporter feeds two consumers: the play API (real players solving hunts) and the editor preview (creators previewing through the iframe). Both receive identical player-safe output. The preview always matches exactly what a real player would experience.

</CardField>
<CardField label="Tradeoff">

Extra type definitions and a transformation function to maintain for every schema change. But the security boundary is structural, not behavioral. You can't accidentally leak answers because `StepPF` physically doesn't carry them. If we add a new sensitive field to `Step`, the compiler forces us to decide whether `StepPF` should include it.

</CardField>
</DecisionCard>

<DecisionCard id="challenge-type-system" title="Challenge Type System">
<CardField label="Context">

Four challenge types (Clue, Quiz, Mission, Task) with completely different field schemas. The editor needs to let creators switch a step between types without destroying shared data like title and description. The API needs to validate based on type. The OpenAPI spec needs to generate clean schemas for all four.

</CardField>
<CardField label="Options">

- **TypeScript discriminated union.** `ClueStep | QuizStep | MissionStep | TaskStep`. Clean type narrowing with exhaustive `switch` statements. Each variant carries exactly the fields it needs. But OpenAPI codegen handles unions poorly. MongoDB stores one shape per document, so switching types means replacing the document. The editor form state would need to be destroyed and recreated on type change.
- **Shared object with nullable fields.** One `Challenge` shape with all four type sub-objects as optional. Only one is populated at a time. Switching types means nulling the old field and setting the new one. Same document, same form state.

</CardField>
<CardField label="Decision">

Shared object. The schema marks `clue`, `quiz`, `mission`, and `task` as optional + nullable. A Zod discriminator at the API layer validates that exactly one is populated and matches the `type` field. The constraint is runtime, not compile-time.

This made three things simpler. OpenAPI generation works with one schema instead of union complexity. MongoDB stores one document shape where partial updates work naturally. The editor switches a step from Quiz to Mission by nulling one field and setting the other. No document recreation, no form state loss.

</CardField>
<CardField label="Tradeoff">

No compile-time exhaustiveness checking. If you access `challenge.quiz` when the type is actually `mission`, TypeScript won't stop you. We compensate with strict API validation and consistent access through helper functions that check the type before accessing the specific challenge field.

</CardField>
</DecisionCard>

<DecisionCard id="ai-integration" title="AI Integration">
<CardField label="Context">

Two distinct AI use cases. First: validating player submissions for Missions (photos of specific locations or objects) and Tasks (audio recordings) where exact matching is impossible. Second: generating complete, playable hunts from a text prompt like "a treasure hunt around Central Park about American history." Multiple AI providers handle different media types, and provider failures can never block a player mid-hunt.

</CardField>
<CardField label="Options">

- **Validation with a single provider.** Simpler integration. But a single point of failure. If OpenAI is down, all Mission and Task validation stops and players can't progress.
- **Validation with multi-provider and hard failure.** Multiple providers, reject submissions when AI is unavailable. Safe, but frustrating for players in the middle of a hunt.
- **Validation with graceful degradation.** Multiple providers, each specialized by media type. If all fail, auto-pass with a flag. Players never blocked.
- **Generation with free-form JSON.** Ask the LLM for JSON, parse, hope it validates. The model hallucinates field names, invents enum values, nests things wrong.
- **Generation with structured outputs.** Enforce the output schema during generation. Enrich with external data after.

</CardField>
<CardField label="Decision">

For validation, GPT-4o handles text validation and Google Gemini handles image and audio analysis. If a provider fails or times out at 15 seconds, validation auto-passes with a `fallbackUsed` flag. Players are never blocked by infrastructure.

The validation prompt adapts based on attempt count. After 2 failed attempts, the AI starts providing subtle hints in its feedback. After 3+, it gives direct guidance. This keeps the experience challenging without being frustrating.

For generation, we use OpenAI Structured Outputs with a Zod schema derived from our API types. The schema uses `Mission.omit({ targetLocation })` so the model generates a description of where to go instead of GPS coordinates, which it would hallucinate. After generation, each step goes through a geocoding pipeline: Google Maps geocodes the location description, and only `ROOFTOP` or `RANGE_INTERPOLATED` precision is accepted. If geocoding fails or returns low precision, the step silently converts from a Mission to a Clue. No unplayable hunts. If schema validation fails, one retry feeds the specific Zod errors back to the model.

</CardField>
<CardField label="Tradeoff">

Auto-pass on validation failure means a bad answer could slip through. But blocking players when AI is down is worse for the experience. The generation quality gate trades geographic coverage for accuracy. Some locations become Clues instead of GPS challenges, but every generated hunt is immediately playable without manual fixes.

</CardField>
</DecisionCard>

---

## Highlights

<CodeShowcase title="Answer Validation" description="Six validators behind one interface. Each challenge type maps to a validator — from Levenshtein distance for fuzzy text to Haversine for GPS proximity to AI for image and audio. Adding a new validator means one map entry. Zero changes to dispatch logic.">

```typescript
interface AnswerValidator {
  validate(
    submission: PlayerSubmission,
    challenge: Challenge,
  ): Promise<ValidationResult>;
}

const validators: Record<AnswerType, AnswerValidator> = {
  "quiz-choice":      new ExactMatchValidator(),
  "quiz-input":       new LevenshteinValidator(),
  "mission-location": new HaversineValidator(),
  "mission-media":    new AIImageValidator([gemini]),
  "task-audio":       new AIAudioValidator([gemini]),
  "task-text":        new AITextValidator([openai]),
};
```

</CodeShowcase>

<ProcessFlow title="Asset Pipeline">
  <ProcessStep label="Client" detail="File selected" />
  <ProcessStep label="Presigned URL" detail="Server generates" />
  <ProcessStep label="S3" detail="Direct upload" />
  <ProcessStep label="CloudFront" detail="CDN delivery" />
</ProcessFlow>

<HighlightGrid>
<HighlightCard title="Session Management">

Sessions are version-locked. Releasing a new version mid-play doesn't interrupt active players. `localStorage` persistence resumes from the last completed step.

</HighlightCard>
<HighlightCard title="Editor Preview">

The Editor embeds the Player in an iframe via a typed `postMessage` protocol. Same `PlayerExporter` as production. Preview matches exactly what real players see.

</HighlightCard>
<HighlightCard title="Prefetching and LRU Cache">

The Player prefetches next-step media with async `decode()` and a bounded LRU cache. Step transitions feel instant because assets are already decoded.

</HighlightCard>
<HighlightCard title="Compass Design System">

`@hunthub/compass` wraps MUI's `createTheme` with shared tokens, typography scales, and responsive mixins. One import gives any app the full design system.

</HighlightCard>
</HighlightGrid>

<CodeShowcase title="Play API and HATEOAS" description="Each API response includes hypermedia links for available actions. The Player follows links — it never decides what comes next. Game rules change server-side without touching the client.">

```json
{
  "step": {
    "id": 3,
    "type": "mission",
    "title": "Find the hidden statue",
    "challenge": { "radius": 50 }
  },
  "_links": {
    "submit": { "href": "/api/play/sessions/abc/submit", "method": "POST" },
    "hint":   { "href": "/api/play/sessions/abc/hint",   "method": "GET"  },
    "skip":   null
  }
}
```

</CodeShowcase>

<ProcessFlow title="Type Generation">
  <ProcessStep label="OpenAPI Spec" detail="Single source of truth" />
  <ProcessStep label="Codegen" detail="openapi-zod-client" />
  <ProcessStep label="Types + Zod" detail="Shared package" />
  <ProcessStep label="CI" detail="Build-time validation" />
</ProcessFlow>

<HighlightGrid>
<HighlightCard title="Hunt Sharing">

Three permission levels (Owner, Admin, View) enforced in server-side middleware. The Editor adapts UI per role, but access control never relies on the client.

</HighlightCard>
<HighlightCard title="Media Processing">

Images are compressed client-side via `browser-image-compression` before upload. Audio is captured at low bitrate (32kbps) through `MediaRecorder`. Only the compressed file is uploaded — no originals stored.

</HighlightCard>
</HighlightGrid>

---

## Reflections

The Hunt/HuntVersion separation was the strongest architectural decision. Optimistic locking on release, version-locked play sessions, and instant rollback all fall out naturally from the pointer model. It handles concurrent edge cases without pessimistic locks.

The step storage model is where the tradeoff didn't pay off. Steps as separate documents made publishing straightforward (clone the documents), but every read requires a secondary query. Embedding steps within `HuntVersion` would make the common read path a single document fetch. The publish operation gets more complex, but reads happen far more often than publishes.

The `PlayerExporter` boundary was worth every extra line of code. It turns a behavioral contract ("don't send answers to players") into a structural one that the type system enforces. Every new sensitive field on `Step` requires an explicit decision about whether `StepPF` carries it.

The iframe SDK is the riskiest integration boundary. Editor and Player deploy independently. A breaking change in the postMessage protocol would silently break preview with no compile-time warning. This needs contract tests between the two apps.

---

## Numbers

<StatGrid>
  <Stat value="4" label="Apps" />
  <Stat value="3" label="Shared Packages" />
  <Stat value="4" label="Challenge Types" />
  <Stat value="6" label="Answer Validators" />
</StatGrid>

---

## Links

- [HedgeHunt](https://hedgehunt.app) — live product
- GitHub — available on request
